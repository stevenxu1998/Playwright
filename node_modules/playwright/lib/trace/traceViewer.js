"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.showTraceViewer = void 0;
const path = require("path");
const util = require("util");
const fs = require("fs");
const fsReadFileAsync = util.promisify(fs.readFile.bind(fs));
class TraceViewer {
    constructor(playwright, traceStorageDir) {
        this._traces = [];
        this._browserNames = new Set();
        this._resourceEventsByUrl = new Map();
        this._contextEventById = new Map();
        this._contextById = new Map();
        this._playwright = playwright;
        this._traceStorageDir = traceStorageDir;
    }
    async load(traceFile) {
        // TODO: validate trace?
        const traceContent = await fsReadFileAsync(traceFile, 'utf8');
        const events = traceContent.split('\n').map(line => line.trim()).filter(line => !!line).map(line => JSON.parse(line));
        for (const event of events) {
            if (event.type === 'context-created')
                this._browserNames.add(event.browserName);
            if (event.type === 'resource') {
                let responseEvents = this._resourceEventsByUrl.get(event.url);
                if (!responseEvents) {
                    responseEvents = [];
                    this._resourceEventsByUrl.set(event.url, responseEvents);
                }
                responseEvents.push(event);
            }
            if (event.type === 'context-created')
                this._contextEventById.set(event.contextId, event);
        }
        this._traces.push({ traceFile, events });
    }
    browserNames() {
        return this._browserNames;
    }
    async show(browserName) {
        const browser = await this._playwright[browserName].launch({ headless: false });
        const uiPage = await browser.newPage();
        await uiPage.exposeBinding('renderSnapshot', async (source, event) => {
            const snapshot = await fsReadFileAsync(path.join(this._traceStorageDir, event.sha1), 'utf8');
            const context = await this._ensureContext(browser, event.contextId);
            const page = await context.newPage();
            await this._renderSnapshot(page, JSON.parse(snapshot), event.contextId);
        });
        const snapshotsPerContext = {};
        for (const trace of this._traces) {
            let contextId = 0;
            for (const event of trace.events) {
                if (event.type !== 'snapshot')
                    continue;
                const contextEvent = this._contextEventById.get(event.contextId);
                if (contextEvent.browserName !== browserName)
                    continue;
                let contextSnapshots = snapshotsPerContext[contextEvent.contextId];
                if (!contextSnapshots) {
                    contextSnapshots = { label: trace.traceFile + ' :: context' + (++contextId), snapshots: [] };
                    snapshotsPerContext[contextEvent.contextId] = contextSnapshots;
                }
                contextSnapshots.snapshots.push(event);
            }
        }
        await uiPage.evaluate(snapshotsPerContext => {
            for (const contextSnapshots of Object.values(snapshotsPerContext)) {
                const header = document.createElement('div');
                header.textContent = contextSnapshots.label;
                header.style.margin = '10px';
                document.body.appendChild(header);
                for (const event of contextSnapshots.snapshots) {
                    const button = document.createElement('button');
                    button.style.display = 'block';
                    button.textContent = `${event.label}`;
                    button.addEventListener('click', () => {
                        window.renderSnapshot(event);
                    });
                    document.body.appendChild(button);
                }
            }
        }, snapshotsPerContext);
    }
    async _ensureContext(browser, contextId) {
        let context = this._contextById.get(contextId);
        if (!context) {
            const event = this._contextEventById.get(contextId);
            context = await browser.newContext({
                isMobile: event.isMobile,
                viewport: event.viewportSize || null,
                deviceScaleFactor: event.deviceScaleFactor,
            });
            this._contextById.set(contextId, context);
        }
        return context;
    }
    async _readResource(event, overrideSha1) {
        try {
            const body = await fsReadFileAsync(path.join(this._traceStorageDir, overrideSha1 || event.sha1));
            return {
                contentType: event.contentType,
                body,
                headers: event.responseHeaders,
            };
        }
        catch (e) {
            return undefined;
        }
    }
    async _renderSnapshot(page, snapshot, contextId) {
        const frameBySrc = new Map();
        for (const frameSnapshot of snapshot.frames)
            frameBySrc.set(frameSnapshot.url, frameSnapshot);
        const intercepted = [];
        const unknownUrls = new Set();
        const unknown = (route) => {
            const url = route.request().url();
            if (!unknownUrls.has(url)) {
                console.log(`Request to unknown url: ${url}`); /* eslint-disable-line no-console */
                unknownUrls.add(url);
            }
            intercepted.push(route.abort());
        };
        await page.route('**', async (route) => {
            const url = route.request().url();
            if (frameBySrc.has(url)) {
                const frameSnapshot = frameBySrc.get(url);
                intercepted.push(route.fulfill({
                    contentType: 'text/html',
                    body: Buffer.from(frameSnapshot.html),
                }));
                return;
            }
            const frameSrc = route.request().frame().url();
            const frameSnapshot = frameBySrc.get(frameSrc);
            if (!frameSnapshot)
                return unknown(route);
            // Find a matching resource from the same context, preferrably from the same frame.
            // Note: resources are stored without hash, but page may reference them with hash.
            let resource = null;
            for (const resourceEvent of this._resourceEventsByUrl.get(removeHash(url)) || []) {
                if (resourceEvent.contextId !== contextId)
                    continue;
                if (resource && resourceEvent.frameId !== frameSnapshot.frameId)
                    continue;
                resource = resourceEvent;
                if (resourceEvent.frameId === frameSnapshot.frameId)
                    break;
            }
            if (!resource)
                return unknown(route);
            // This particular frame might have a resource content override, for example when
            // stylesheet is modified using CSSOM.
            const resourceOverride = frameSnapshot.resourceOverrides.find(o => o.url === url);
            const overrideSha1 = resourceOverride ? resourceOverride.sha1 : undefined;
            const resourceData = await this._readResource(resource, overrideSha1);
            if (!resourceData)
                return unknown(route);
            const headers = {};
            for (const { name, value } of resourceData.headers)
                headers[name] = value;
            headers['Access-Control-Allow-Origin'] = '*';
            intercepted.push(route.fulfill({
                contentType: resourceData.contentType,
                body: resourceData.body,
                headers,
            }));
        });
        await page.goto(snapshot.frames[0].url);
        await this._postprocessSnapshotFrame(snapshot, snapshot.frames[0], page.mainFrame());
        await Promise.all(intercepted);
    }
    async _postprocessSnapshotFrame(snapshot, frameSnapshot, frame) {
        for (const childFrame of frame.childFrames()) {
            await childFrame.waitForLoadState();
            const url = childFrame.url();
            for (const childData of snapshot.frames) {
                if (url.endsWith(childData.url))
                    await this._postprocessSnapshotFrame(snapshot, childData, childFrame);
            }
        }
    }
}
async function showTraceViewer(playwright, traceStorageDir, traceFiles) {
    const traceViewer = new TraceViewer(playwright, traceStorageDir);
    for (const traceFile of traceFiles)
        await traceViewer.load(traceFile);
    for (const browserName of traceViewer.browserNames())
        await traceViewer.show(browserName);
}
exports.showTraceViewer = showTraceViewer;
function removeHash(url) {
    try {
        const u = new URL(url);
        u.hash = '';
        return u.toString();
    }
    catch (e) {
        return url;
    }
}
//# sourceMappingURL=traceViewer.js.map
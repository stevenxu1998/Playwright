"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracer = void 0;
const path = require("path");
const util = require("util");
const fs = require("fs");
const utils_1 = require("../utils/utils");
const instrumentation_1 = require("../server/instrumentation");
const progress_1 = require("../server/progress");
const snapshotter_1 = require("./snapshotter");
const fsWriteFileAsync = util.promisify(fs.writeFile.bind(fs));
const fsAppendFileAsync = util.promisify(fs.appendFile.bind(fs));
const fsAccessAsync = util.promisify(fs.access.bind(fs));
class Tracer {
    constructor() {
        this._contextTracers = new Map();
        instrumentation_1.instrumentingAgents.add(this);
    }
    dispose() {
        instrumentation_1.instrumentingAgents.delete(this);
    }
    traceContext(context, traceStorageDir, traceFile) {
        const contextTracer = new ContextTracer(context, traceStorageDir, traceFile);
        this._contextTracers.set(context, contextTracer);
    }
    async captureSnapshot(page, options = {}) {
        return progress_1.runAbortableTask(async (progress) => {
            const contextTracer = this._contextTracers.get(page.context());
            if (contextTracer)
                await contextTracer._snapshotter.takeSnapshot(progress, page, options.label || 'snapshot');
        }, page._timeoutSettings.timeout(options));
    }
    async onContextCreated(context) {
    }
    async onContextDestroyed(context) {
        const contextTracer = this._contextTracers.get(context);
        if (contextTracer) {
            await contextTracer.dispose();
            this._contextTracers.delete(context);
        }
    }
    async onBeforePageAction(page, progress) {
        const contextTracer = this._contextTracers.get(page.context());
        if (contextTracer)
            await contextTracer._snapshotter.takeSnapshot(progress, page, 'progress');
    }
}
exports.Tracer = Tracer;
class ContextTracer {
    constructor(context, traceStorageDir, traceFile) {
        this._contextId = 'context@' + utils_1.createGuid();
        this._traceStoragePromise = utils_1.mkdirIfNeeded(path.join(traceStorageDir, 'sha1')).then(() => traceStorageDir);
        this._appendEventChain = utils_1.mkdirIfNeeded(traceFile).then(() => traceFile);
        this._writeArtifactChain = Promise.resolve();
        const event = {
            type: 'context-created',
            browserName: context._browser._options.name,
            contextId: this._contextId,
            isMobile: !!context._options.isMobile,
            deviceScaleFactor: context._options.deviceScaleFactor || 1,
            viewportSize: context._options.viewport || undefined,
        };
        this._appendTraceEvent(event);
        this._snapshotter = new snapshotter_1.Snapshotter(context, this);
    }
    onBlob(blob) {
        this._writeArtifact(blob.sha1, blob.buffer);
    }
    onResource(resource) {
        const event = {
            type: 'resource',
            contextId: this._contextId,
            frameId: resource.frameId,
            url: resource.url,
            contentType: resource.contentType,
            responseHeaders: resource.responseHeaders,
            sha1: resource.sha1,
        };
        this._appendTraceEvent(event);
    }
    onSnapshot(snapshot) {
        const buffer = Buffer.from(JSON.stringify(snapshot));
        const sha1 = utils_1.calculateSha1(buffer);
        const event = {
            type: 'snapshot',
            contextId: this._contextId,
            label: snapshot.label,
            sha1,
        };
        this._appendTraceEvent(event);
        this._writeArtifact(sha1, buffer);
    }
    async dispose() {
        this._snapshotter.dispose();
        const event = {
            type: 'context-destroyed',
            contextId: this._contextId,
        };
        this._appendTraceEvent(event);
        // Ensure all writes are finished.
        await this._appendEventChain;
        await this._writeArtifactChain;
    }
    _writeArtifact(sha1, buffer) {
        // Save all write promises to wait for them in dispose.
        const promise = this._innerWriteArtifact(sha1, buffer);
        this._writeArtifactChain = this._writeArtifactChain.then(() => promise);
    }
    async _innerWriteArtifact(sha1, buffer) {
        const traceDirectory = await this._traceStoragePromise;
        const filePath = path.join(traceDirectory, sha1);
        try {
            await fsAccessAsync(filePath);
        }
        catch (e) {
            // File does not exist - write it.
            await fsWriteFileAsync(filePath, buffer);
        }
    }
    _appendTraceEvent(event) {
        // Serialize all writes to the trace file.
        const timestamp = utils_1.monotonicTime();
        this._appendEventChain = this._appendEventChain.then(async (traceFile) => {
            await fsAppendFileAsync(traceFile, JSON.stringify({ ...event, timestamp }) + '\n');
            return traceFile;
        });
    }
}
//# sourceMappingURL=tracer.js.map
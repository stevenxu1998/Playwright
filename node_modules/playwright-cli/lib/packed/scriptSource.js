/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/injected/script.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./src/injected/consoleApi.ts":
/*!************************************!*\
  !*** ./src/injected/consoleApi.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleAPI = void 0;
const selectorGenerator_1 = __webpack_require__(/*! ./selectorGenerator */ "./src/injected/selectorGenerator.ts");
;
class ConsoleAPI {
    constructor(injectedScript) {
        this._injectedScript = injectedScript;
        window.playwright = {
            $: (selector) => this.querySelector(selector),
            $$: (selector) => this.querySelectorAll(selector),
            inspect: (selector) => this.inspect(selector),
            selector: (element) => this.buildSelector(element).selector,
        };
    }
    _checkSelector(parsed) {
        for (const { name } of parsed.parts) {
            if (!this._injectedScript.engines.has(name))
                throw new Error(`Unknown engine "${name}"`);
        }
    }
    querySelector(selector) {
        if (typeof selector !== 'string')
            throw new Error(`Usage: playwright.$('Playwright >> selector').`);
        const parsed = this._injectedScript.parseSelector(selector);
        this._checkSelector(parsed);
        const elements = this._injectedScript.querySelectorAll(parsed, document);
        return elements[0];
    }
    querySelectorAll(selector) {
        if (typeof selector !== 'string')
            throw new Error(`Usage: playwright.$$('Playwright >> selector').`);
        const parsed = this._injectedScript.parseSelector(selector);
        this._checkSelector(parsed);
        return this._injectedScript.querySelectorAll(parsed, document);
    }
    inspect(selector) {
        if (typeof window.inspect !== 'function')
            return;
        if (typeof selector !== 'string')
            throw new Error(`Usage: playwright.inspect('Playwright >> selector').`);
        window.inspect(this.querySelector(selector));
    }
    buildSelector(element) {
        return selectorGenerator_1.buildSelector(this._injectedScript, element);
    }
}
exports.ConsoleAPI = ConsoleAPI;


/***/ }),

/***/ "./src/injected/html.ts":
/*!******************************!*\
  !*** ./src/injected/html.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepActiveElement = exports.html = exports.onDOMResize = exports.onDOMEvent = void 0;
const templateCache = new Map();
const BOOLEAN_ATTRS = new Set([
    'async', 'autofocus', 'autoplay', 'checked', 'contenteditable', 'controls',
    'default', 'defer', 'disabled', 'expanded', 'formNoValidate', 'frameborder', 'hidden',
    'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate',
    'open', 'readonly', 'required', 'reversed', 'scoped', 'selected', 'typemustmatch',
]);
function onDOMEvent(target, name, listener, capturing = false) {
    target.addEventListener(name, listener, capturing);
    return () => {
        target.removeEventListener(name, listener, capturing);
    };
}
exports.onDOMEvent = onDOMEvent;
function onDOMResize(target, callback) {
    const resizeObserver = new window.ResizeObserver(callback);
    resizeObserver.observe(target);
    return () => resizeObserver.disconnect();
}
exports.onDOMResize = onDOMResize;
function html(strings, ...values) {
    let cache = templateCache.get(strings);
    if (!cache) {
        cache = prepareTemplate(strings);
        templateCache.set(strings, cache);
    }
    const node = renderTemplate(cache.template, cache.subs, values);
    if (node.querySelector) {
        node.$ = node.querySelector.bind(node);
        node.$$ = node.querySelectorAll.bind(node);
    }
    return node;
}
exports.html = html;
const SPACE_REGEX = /^\s*\n\s*$/;
const MARKER_REGEX = /---dom-template-\d+---/;
function prepareTemplate(strings) {
    const template = document.createElement('template');
    let html = '';
    for (let i = 0; i < strings.length - 1; ++i) {
        html += strings[i];
        html += `---dom-template-${i}---`;
    }
    html += strings[strings.length - 1];
    template.innerHTML = html;
    const walker = template.ownerDocument.createTreeWalker(template.content, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
    const emptyTextNodes = [];
    const subs = [];
    while (walker.nextNode()) {
        const node = walker.currentNode;
        if (node.nodeType === Node.ELEMENT_NODE && MARKER_REGEX.test(node.tagName))
            throw new Error('Should not use a parameter as an html tag');
        if (node.nodeType === Node.ELEMENT_NODE && node.hasAttributes()) {
            const element = node;
            for (let i = 0; i < element.attributes.length; i++) {
                const name = element.attributes[i].name;
                const nameParts = name.split(MARKER_REGEX);
                const valueParts = element.attributes[i].value.split(MARKER_REGEX);
                const isSimpleValue = valueParts.length === 2 && valueParts[0] === '' && valueParts[1] === '';
                if (nameParts.length > 1 || valueParts.length > 1)
                    subs.push({ node: element, nameParts, valueParts, isSimpleValue, attr: name });
            }
        }
        else if (node.nodeType === Node.TEXT_NODE && MARKER_REGEX.test(node.data)) {
            const text = node;
            const texts = text.data.split(MARKER_REGEX);
            text.data = texts[0];
            const anchor = node.nextSibling;
            for (let i = 1; i < texts.length; ++i) {
                const span = document.createElement('span');
                node.parentNode.insertBefore(span, anchor);
                node.parentNode.insertBefore(document.createTextNode(texts[i]), anchor);
                subs.push({
                    node: span,
                    type: 'replace-node',
                });
            }
            if (shouldRemoveTextNode(text))
                emptyTextNodes.push(text);
        }
        else if (node.nodeType === Node.TEXT_NODE && shouldRemoveTextNode(node)) {
            emptyTextNodes.push(node);
        }
    }
    for (const emptyTextNode of emptyTextNodes)
        emptyTextNode.remove();
    const markedNodes = new Map();
    for (const sub of subs) {
        let index = markedNodes.get(sub.node);
        if (index === undefined) {
            index = markedNodes.size;
            sub.node.setAttribute('dom-template-marked', 'true');
            markedNodes.set(sub.node, index);
        }
        sub.nodeIndex = index;
    }
    return { template, subs };
}
function shouldRemoveTextNode(node) {
    if (!node.previousSibling && !node.nextSibling)
        return !node.data.length;
    return (!node.previousSibling || node.previousSibling.nodeType === Node.ELEMENT_NODE) &&
        (!node.nextSibling || node.nextSibling.nodeType === Node.ELEMENT_NODE) &&
        (!node.data.length || SPACE_REGEX.test(node.data));
}
function renderTemplate(template, subs, values) {
    const content = template.ownerDocument.importNode(template.content, true);
    const boundElements = Array.from(content.querySelectorAll('[dom-template-marked]'));
    for (const node of boundElements)
        node.removeAttribute('dom-template-marked');
    let valueIndex = 0;
    const interpolateText = (texts) => {
        let newText = texts[0];
        for (let i = 1; i < texts.length; ++i) {
            newText += values[valueIndex++];
            newText += texts[i];
        }
        return newText;
    };
    for (const sub of subs) {
        const n = boundElements[sub.nodeIndex];
        if (sub.attr) {
            n.removeAttribute(sub.attr);
            const name = interpolateText(sub.nameParts);
            const value = sub.isSimpleValue ? values[valueIndex++] : interpolateText(sub.valueParts);
            if (BOOLEAN_ATTRS.has(name))
                n.toggleAttribute(name, !!value);
            else
                n.setAttribute(name, String(value));
        }
        else if (sub.type === 'replace-node') {
            const replacement = values[valueIndex++];
            if (Array.isArray(replacement)) {
                const fragment = document.createDocumentFragment();
                for (const node of replacement)
                    fragment.appendChild(node);
                n.replaceWith(fragment);
            }
            else if (replacement instanceof Node) {
                n.replaceWith(replacement);
            }
            else {
                n.replaceWith(document.createTextNode(replacement || ''));
            }
        }
    }
    return content.firstChild && content.firstChild === content.lastChild ? content.firstChild : content;
}
function deepActiveElement() {
    let activeElement = document.activeElement;
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
        activeElement = activeElement.shadowRoot.activeElement;
    return activeElement;
}
exports.deepActiveElement = deepActiveElement;


/***/ }),

/***/ "./src/injected/recorder.ts":
/*!**********************************!*\
  !*** ./src/injected/recorder.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Recorder = void 0;
const consoleApi_1 = __webpack_require__(/*! ./consoleApi */ "./src/injected/consoleApi.ts");
const html_1 = __webpack_require__(/*! ./html */ "./src/injected/html.ts");
const util_1 = __webpack_require__(/*! ./util */ "./src/injected/util.ts");
const scriptSymbol = Symbol('scriptSymbol');
class Recorder {
    constructor(injectedScript, consoleAPI) {
        this._performingAction = false;
        this._highlightElements = [];
        this._listeners = [];
        this._hoveredModel = null;
        this._hoveredElement = null;
        this._activeModel = null;
        this._expectProgrammaticKeyUp = false;
        this._consoleAPI = consoleAPI;
        this._outerGlassPaneElement = html_1.html `
      <x-pw-glass style="
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        z-index: 1000000;
        pointer-events: none;
        display: flex;
      ">
      </x-pw-glass>`;
        this._tooltipElement = html_1.html `<x-pw-tooltip></x-pw-tooltip>`;
        this._innerGlassPaneElement = html_1.html `
      <x-pw-glass-inner style="flex: auto">
        ${this._tooltipElement}
      </x-pw-glass-inner>`;
        // Use a closed shadow root to prevent selectors matching our internal previews.
        this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({ mode: 'closed' });
        this._glassPaneShadow.appendChild(this._innerGlassPaneElement);
        this._glassPaneShadow.appendChild(html_1.html `
      <style>
        x-pw-tooltip {
          align-items: center;
          backdrop-filter: blur(5px);
          background-color: rgba(0, 0, 0, 0.7);
          border-radius: 2px;
          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,
                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,
                      rgba(0, 0, 0, 0.1) 0px -2px 4px,
                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,
                      rgba(0, 0, 0, 0.25) 0px 54px 55px;
          color: rgb(204, 204, 204);
          display: flex;
          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',
                       'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;
          font-size: 12.8px;
          font-weight: normal;
          left: 0;
          line-height: 1.5;
          max-width: 600px;
          padding: 3.2px 5.12px 3.2px;
          position: absolute;
          top: 0;
        }
    </style>
    `);
        setInterval(() => {
            this._refreshListenersIfNeeded();
        }, 100);
        this._consoleAPI = new consoleApi_1.ConsoleAPI(injectedScript);
    }
    _refreshListenersIfNeeded() {
        if (document.documentElement[scriptSymbol])
            return;
        document.documentElement[scriptSymbol] = true;
        util_1.removeEventListeners(this._listeners);
        this._listeners = [
            util_1.addEventListener(document, 'click', event => this._onClick(event), true),
            util_1.addEventListener(document, 'input', event => this._onInput(event), true),
            util_1.addEventListener(document, 'keydown', event => this._onKeyDown(event), true),
            util_1.addEventListener(document, 'keyup', event => this._onKeyUp(event), true),
            util_1.addEventListener(document, 'mousedown', event => this._onMouseDown(event), true),
            util_1.addEventListener(document, 'mouseup', event => this._onMouseUp(event), true),
            util_1.addEventListener(document, 'mousemove', event => this._onMouseMove(event), true),
            util_1.addEventListener(document, 'mouseleave', event => this._onMouseLeave(event), true),
            util_1.addEventListener(document, 'focus', event => this._onFocus(event), true),
            util_1.addEventListener(document, 'scroll', event => {
                this._hoveredModel = null;
                this._updateHighlight();
            }, true),
        ];
        document.documentElement.appendChild(this._outerGlassPaneElement);
        if (window._recorderScriptReadyForTest)
            window._recorderScriptReadyForTest();
    }
    _actionInProgress(event) {
        // If Playwright is performing action for us, bail.
        if (this._performingAction)
            return true;
        // Consume as the first thing.
        consumeEvent(event);
        return false;
    }
    _consumedDueToNoModel(event, model) {
        if (model)
            return false;
        consumeEvent(event);
        return true;
    }
    _consumedDueWrongTarget(event) {
        if (this._activeModel && this._activeModel.elements[0] === event.target)
            return false;
        consumeEvent(event);
        return true;
    }
    _onClick(event) {
        if (event.target.nodeName === 'SELECT')
            return;
        if (event.target.nodeName === 'INPUT') {
            // Check/uncheck are handled in input.
            if ((event.target.type || '').toLowerCase() === 'checkbox')
                return;
        }
        if (this._actionInProgress(event))
            return;
        if (this._consumedDueToNoModel(event, this._hoveredModel))
            return;
        this._performAction({
            name: 'click',
            selector: this._hoveredModel.selector,
            signals: [],
            button: buttonForEvent(event),
            modifiers: modifiersForEvent(event),
            clickCount: event.detail
        });
    }
    _onMouseDown(event) {
        if (!this._performingAction)
            consumeEvent(event);
        this._activeModel = this._hoveredModel;
    }
    _onMouseUp(event) {
        if (!this._performingAction)
            consumeEvent(event);
    }
    _onMouseMove(event) {
        if (this._hoveredElement === event.target)
            return;
        this._hoveredElement = event.target;
        // Mouse moved -> mark last action as committed via committing a commit action.
        this._commitActionAndUpdateModelForHoveredElement();
    }
    _onMouseLeave(event) {
        // Leaving iframe.
        if (event.target.nodeType === Node.DOCUMENT_NODE) {
            this._hoveredElement = null;
            this._commitActionAndUpdateModelForHoveredElement();
        }
    }
    _onFocus(event) {
        const result = document.activeElement ? this._consoleAPI.buildSelector(document.activeElement) : null;
        this._activeModel = result && result.selector ? result : null;
        if (window._highlightUpdatedForTest)
            window._highlightUpdatedForTest(result ? result.selector : null);
    }
    _commitActionAndUpdateModelForHoveredElement() {
        if (!this._hoveredElement) {
            this._hoveredModel = null;
            this._updateHighlight();
            return;
        }
        const hoveredElement = this._hoveredElement;
        const { selector, elements } = this._consoleAPI.buildSelector(hoveredElement);
        if ((this._hoveredModel && this._hoveredModel.selector === selector) || this._hoveredElement !== hoveredElement)
            return;
        window.commitLastAction();
        this._hoveredModel = selector ? { selector, elements } : null;
        this._updateHighlight();
        if (window._highlightUpdatedForTest)
            window._highlightUpdatedForTest(selector);
    }
    _updateHighlight() {
        const elements = this._hoveredModel ? this._hoveredModel.elements : [];
        // Code below should trigger one layout and leave with the
        // destroyed layout.
        // Destroy the layout
        this._tooltipElement.textContent = this._hoveredModel ? this._hoveredModel.selector : '';
        this._tooltipElement.style.top = '0';
        this._tooltipElement.style.left = '0';
        this._tooltipElement.style.display = 'flex';
        // Trigger layout.
        const boxes = elements.map(e => e.getBoundingClientRect());
        const tooltipWidth = this._tooltipElement.offsetWidth;
        const tooltipHeight = this._tooltipElement.offsetHeight;
        const totalWidth = this._innerGlassPaneElement.offsetWidth;
        const totalHeight = this._innerGlassPaneElement.offsetHeight;
        // Destroy the layout again.
        if (boxes.length) {
            const primaryBox = boxes[0];
            let anchorLeft = primaryBox.left;
            if (anchorLeft + tooltipWidth > totalWidth - 5)
                anchorLeft = totalWidth - tooltipWidth - 5;
            let anchorTop = primaryBox.bottom + 5;
            if (anchorTop + tooltipHeight > totalHeight - 5) {
                // If can't fit below, either position above...
                if (primaryBox.top > tooltipHeight + 5) {
                    anchorTop = primaryBox.top - tooltipHeight - 5;
                }
                else {
                    // Or on top in case of large element
                    anchorTop = totalHeight - 5 - tooltipHeight;
                }
            }
            this._tooltipElement.style.top = anchorTop + 'px';
            this._tooltipElement.style.left = anchorLeft + 'px';
        }
        else {
            this._tooltipElement.style.display = 'none';
        }
        const pool = this._highlightElements;
        this._highlightElements = [];
        for (const box of boxes) {
            const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();
            highlightElement.style.borderColor = this._highlightElements.length ? 'hotpink' : '#8929ff';
            highlightElement.style.left = box.x + 'px';
            highlightElement.style.top = box.y + 'px';
            highlightElement.style.width = box.width + 'px';
            highlightElement.style.height = box.height + 'px';
            highlightElement.style.display = 'block';
            this._highlightElements.push(highlightElement);
        }
        for (const highlightElement of pool) {
            highlightElement.style.display = 'none';
            this._highlightElements.push(highlightElement);
        }
    }
    _createHighlightElement() {
        const highlightElement = html_1.html `
      <x-pw-highlight style="
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: 0;
        border: 1px solid;
        box-sizing: border-box;">
      </x-pw-highlight>`;
        this._glassPaneShadow.appendChild(highlightElement);
        return highlightElement;
    }
    _onInput(event) {
        if (['INPUT', 'TEXTAREA'].includes(event.target.nodeName)) {
            const inputElement = event.target;
            const elementType = (inputElement.type || '').toLowerCase();
            if (elementType === 'checkbox') {
                if (this._actionInProgress(event))
                    return;
                if (this._consumedDueWrongTarget(event))
                    return;
                this._performAction({
                    name: inputElement.checked ? 'check' : 'uncheck',
                    selector: this._activeModel.selector,
                    signals: [],
                });
                return;
            }
            if (elementType === "file") {
                window.recordPlaywrightAction({
                    name: 'setInputFiles',
                    selector: this._activeModel.selector,
                    signals: [],
                    files: [...(inputElement.files || [])].map(file => file.name),
                });
                return;
            }
            // Non-navigating actions are simply recorded by Playwright.
            if (this._consumedDueWrongTarget(event))
                return;
            window.recordPlaywrightAction({
                name: 'fill',
                selector: this._activeModel.selector,
                signals: [],
                text: inputElement.value,
            });
        }
        if (event.target.nodeName === 'SELECT') {
            const selectElement = event.target;
            if (this._actionInProgress(event))
                return;
            this._performAction({
                name: 'select',
                selector: this._hoveredModel.selector,
                options: [...selectElement.selectedOptions].map(option => option.value),
                signals: []
            });
        }
    }
    _shouldGenerateKeyPressFor(event) {
        // Backspace, Delete are changing input, will handle it there.
        if (['Backspace', 'Delete'].includes(event.key))
            return false;
        // Ignore the QWERTZ shortcut for creating a at sign on MacOS
        if (event.key === "@" && event.code === "KeyL")
            return false;
        // Allow and ignore common used shortcut for pasting.
        if (process.platform === 'darwin') {
            if (event.key === 'v' && event.metaKey)
                return false;
        }
        else {
            if (event.key === 'v' && event.ctrlKey)
                return false;
            if (event.key === 'Insert' && event.shiftKey)
                return false;
        }
        if (['Shift', 'Control', 'Meta', 'Alt'].includes(event.key))
            return false;
        const hasModifier = event.ctrlKey || event.altKey || event.metaKey;
        if (event.key.length === 1 && !hasModifier)
            return false;
        return true;
    }
    _onKeyDown(event) {
        if (!this._shouldGenerateKeyPressFor(event))
            return;
        if (this._actionInProgress(event)) {
            this._expectProgrammaticKeyUp = true;
            return;
        }
        if (this._consumedDueWrongTarget(event))
            return;
        this._performAction({
            name: 'press',
            selector: this._activeModel.selector,
            signals: [],
            key: event.key,
            modifiers: modifiersForEvent(event),
        });
    }
    _onKeyUp(event) {
        if (!this._shouldGenerateKeyPressFor(event))
            return;
        // Only allow programmatic keyups, ignore user input.
        if (!this._expectProgrammaticKeyUp) {
            consumeEvent(event);
            return;
        }
        this._expectProgrammaticKeyUp = false;
    }
    async _performAction(action) {
        this._performingAction = true;
        await window.performPlaywrightAction(action);
        this._performingAction = false;
        if (window._actionPerformedForTest)
            window._actionPerformedForTest();
    }
}
exports.Recorder = Recorder;
function modifiersForEvent(event) {
    return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);
}
function buttonForEvent(event) {
    switch (event.which) {
        case 1: return 'left';
        case 2: return 'middle';
        case 3: return 'right';
    }
    return 'left';
}
function consumeEvent(e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./src/injected/script.ts":
/*!********************************!*\
  !*** ./src/injected/script.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const consoleApi_1 = __webpack_require__(/*! ./consoleApi */ "./src/injected/consoleApi.ts");
const recorder_1 = __webpack_require__(/*! ./recorder */ "./src/injected/recorder.ts");
class Script {
    constructor(injectedScript, options) {
        if (window.playwright)
            return;
        this._consoleAPI = new consoleApi_1.ConsoleAPI(injectedScript);
        if (options.enableRecorder)
            this._recorder = new recorder_1.Recorder(injectedScript, this._consoleAPI);
    }
}
exports.default = Script;


/***/ }),

/***/ "./src/injected/selectorGenerator.ts":
/*!*******************************************!*\
  !*** ./src/injected/selectorGenerator.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSelector = void 0;
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xpathSelectorEngine_1 = __webpack_require__(/*! ./xpathSelectorEngine */ "./src/injected/xpathSelectorEngine.ts");
function buildSelector(injectedScript, targetElement) {
    const path = [];
    let numberOfMatchingElements = Number.MAX_SAFE_INTEGER;
    for (let element = targetElement; element && element !== document.documentElement; element = element.parentElement) {
        const selector = buildSelectorCandidate(injectedScript, element);
        if (!selector)
            continue;
        const fullSelector = joinSelector([selector, ...path]);
        const parsedSelector = injectedScript.parseSelector(fullSelector);
        const selectorTargets = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);
        if (!selectorTargets.length)
            break;
        if (selectorTargets[0] === targetElement)
            return { selector: fullSelector, elements: selectorTargets };
        if (selectorTargets.length && numberOfMatchingElements > selectorTargets.length) {
            numberOfMatchingElements = selectorTargets.length;
            path.unshift(selector);
        }
    }
    const xpathSelector = xpathSelectorEngine_1.XPathEngine.create(document.documentElement, targetElement, 'default');
    const parsedSelector = injectedScript.parseSelector(xpathSelector);
    return {
        selector: xpathSelector,
        elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)
    };
}
exports.buildSelector = buildSelector;
function buildSelectorCandidate(injectedScript, element) {
    const nodeName = element.nodeName.toLowerCase();
    for (const attribute of ['data-testid', 'data-test-id', 'data-test']) {
        if (element.hasAttribute(attribute))
            return { engine: 'css', selector: `${nodeName}[${attribute}=${quoteString(element.getAttribute(attribute))}]` };
    }
    for (const attribute of ['aria-label', 'role']) {
        if (element.hasAttribute(attribute))
            return { engine: 'css', selector: `${element.nodeName.toLocaleLowerCase()}[${attribute}=${quoteString(element.getAttribute(attribute))}]` };
    }
    if (['INPUT', 'TEXTAREA'].includes(element.nodeName)) {
        const nodeNameLowercase = element.nodeName.toLowerCase();
        if (element.getAttribute('name'))
            return { engine: 'css', selector: `${nodeNameLowercase}[name=${quoteString(element.getAttribute('name'))}]` };
        if (element.getAttribute('placeholder'))
            return { engine: 'css', selector: `${nodeNameLowercase}[placeholder=${quoteString(element.getAttribute('placeholder'))}]` };
        if (element.getAttribute('type'))
            return { engine: 'css', selector: `${nodeNameLowercase}[type=${quoteString(element.getAttribute('type'))}]` };
    }
    else if (element.nodeName === 'IMG') {
        if (element.getAttribute('alt'))
            return { engine: 'css', selector: `img[alt=${quoteString(element.getAttribute('alt'))}]` };
    }
    const textSelector = textSelectorForElement(element);
    if (textSelector)
        return { engine: 'text', selector: textSelector };
    // De-prioritize id, but still use it as a last resort.
    const idAttr = element.getAttribute('id');
    if (idAttr && !isGuidLike(idAttr))
        return { engine: 'css', selector: `${nodeName}[id=${quoteString(idAttr)}]` };
    return null;
}
function textSelectorForElement(node) {
    const maxLength = 30;
    let needsRegex = false;
    let trimmedText = null;
    for (const child of node.childNodes) {
        if (child.nodeType !== Node.TEXT_NODE)
            continue;
        if (child.textContent && child.textContent.trim()) {
            if (trimmedText)
                return null;
            trimmedText = child.textContent.trim().substr(0, maxLength);
            needsRegex = child.textContent !== trimmedText;
        }
        else {
            needsRegex = true;
        }
    }
    if (!trimmedText)
        return null;
    return needsRegex ? `/.*${escapeForRegex(trimmedText)}.*/` : `"${trimmedText}"`;
}
function escapeForRegex(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function quoteString(text) {
    return `"${text.replaceAll(/"/g, '\\"')}"`;
}
function joinSelector(path) {
    const tokens = [];
    let lastEngine = '';
    for (const { engine, selector } of path) {
        if (tokens.length && (lastEngine !== 'css' || engine !== 'css'))
            tokens.push('>>');
        lastEngine = engine;
        if (engine === 'css')
            tokens.push(selector);
        else
            tokens.push(`${engine}=${selector}`);
    }
    return tokens.join(' ');
}
function isGuidLike(id) {
    let lastCharacterType;
    let transitionCount = 0;
    for (let i = 0; i < id.length; ++i) {
        const c = id[i];
        let characterType;
        if (c === '-' || c === '_')
            continue;
        if (c >= 'a' && c <= 'z')
            characterType = 'lower';
        else if (c >= 'A' && c <= 'Z')
            characterType = 'upper';
        else if (c >= '0' && c <= '9')
            characterType = 'digit';
        else
            characterType = 'other';
        if (characterType === 'lower' && lastCharacterType === 'upper') {
            lastCharacterType = characterType;
            continue;
        }
        if (lastCharacterType && lastCharacterType !== characterType)
            ++transitionCount;
        lastCharacterType = characterType;
    }
    return transitionCount >= id.length / 4;
}


/***/ }),

/***/ "./src/injected/util.ts":
/*!******************************!*\
  !*** ./src/injected/util.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeEventListeners = exports.addEventListener = void 0;
function addEventListener(target, eventName, listener, useCapture) {
    target.addEventListener(eventName, listener, useCapture);
    return { target, eventName, listener, useCapture };
}
exports.addEventListener = addEventListener;
function removeEventListeners(listeners) {
    for (const listener of listeners)
        listener.target.removeEventListener(listener.eventName, listener.listener, listener.useCapture);
    listeners.splice(0, listeners.length);
}
exports.removeEventListeners = removeEventListeners;


/***/ }),

/***/ "./src/injected/xpathSelectorEngine.ts":
/*!*********************************************!*\
  !*** ./src/injected/xpathSelectorEngine.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XPathEngine = void 0;
const maxTextLength = 80;
const minMeaningfulSelectorLegth = 100;
exports.XPathEngine = {
    create(root, targetElement, type) {
        const maybeDocument = root instanceof Document ? root : root.ownerDocument;
        if (!maybeDocument)
            return;
        const document = maybeDocument;
        const xpathCache = new Map();
        const tokens = [];
        function evaluateXPath(expression) {
            let nodes = xpathCache.get(expression);
            if (!nodes) {
                nodes = [];
                try {
                    const result = document.evaluate(expression, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
                    for (let node = result.iterateNext(); node; node = result.iterateNext()) {
                        if (node.nodeType === Node.ELEMENT_NODE)
                            nodes.push(node);
                    }
                }
                catch (e) {
                }
                xpathCache.set(expression, nodes);
            }
            return nodes;
        }
        function uniqueXPathSelector(prefix) {
            const path = tokens.slice();
            if (prefix)
                path.unshift(prefix);
            let selector = '//' + path.join('/');
            while (selector.includes('///'))
                selector = selector.replace('///', '//');
            if (selector.endsWith('/'))
                selector = selector.substring(0, selector.length - 1);
            const nodes = evaluateXPath(selector);
            if (nodes[0] === targetElement)
                return selector;
            // If we are looking at a small set of elements with long selector, fall back to ordinal.
            if (nodes.length < 5 && selector.length > minMeaningfulSelectorLegth) {
                const index = nodes.indexOf(targetElement);
                if (index !== -1)
                    return `(${selector})[${index + 1}]`;
            }
            return undefined;
        }
        function escapeAndCap(text) {
            text = text.substring(0, maxTextLength);
            // XPath 1.0 does not support quote escaping.
            // 1. If there are no single quotes - use them.
            if (text.indexOf(`'`) === -1)
                return `'${text}'`;
            // 2. If there are no double quotes - use them to enclose text.
            if (text.indexOf(`"`) === -1)
                return `"${text}"`;
            // 3. Otherwise, use popular |concat| trick.
            const Q = `'`;
            return `concat(${text.split(Q).map(token => Q + token + Q).join(`, "'", `)})`;
        }
        const defaultAttributes = new Set(['title', 'aria-label', 'disabled', 'role']);
        const importantAttributes = new Map([
            ['form', ['action']],
            ['img', ['alt']],
            ['input', ['placeholder', 'type', 'name']],
            ['textarea', ['placeholder', 'type', 'name']],
        ]);
        let usedTextConditions = false;
        for (let element = targetElement; element && element !== root; element = element.parentElement) {
            const nodeName = element.nodeName.toLowerCase();
            const tag = nodeName === 'svg' ? '*' : nodeName;
            const tagConditions = [];
            if (nodeName === 'svg')
                tagConditions.push('local-name()="svg"');
            const attrConditions = [];
            const importantAttrs = [...defaultAttributes, ...(importantAttributes.get(tag) || [])];
            for (const attr of importantAttrs) {
                const value = element.getAttribute(attr);
                if (value && value.length < maxTextLength)
                    attrConditions.push(`normalize-space(@${attr})=${escapeAndCap(value)}`);
                else if (value)
                    attrConditions.push(`starts-with(normalize-space(@${attr}), ${escapeAndCap(value)})`);
            }
            const text = document.evaluate('normalize-space(.)', element).stringValue;
            const textConditions = [];
            if (tag !== 'select' && text.length && !usedTextConditions) {
                if (text.length < maxTextLength)
                    textConditions.push(`normalize-space(.)=${escapeAndCap(text)}`);
                else
                    textConditions.push(`starts-with(normalize-space(.), ${escapeAndCap(text)})`);
                usedTextConditions = true;
            }
            // Always retain the last tag.
            const conditions = [...tagConditions, ...textConditions, ...attrConditions];
            const token = conditions.length ? `${tag}[${conditions.join(' and ')}]` : (tokens.length ? '' : tag);
            const selector = uniqueXPathSelector(token);
            if (selector)
                return selector;
            const parent = element.parentElement;
            let ordinal = -1;
            if (parent) {
                const siblings = Array.from(parent.children);
                const sameTagSiblings = siblings.filter(sibling => (sibling).nodeName.toLowerCase() === nodeName);
                if (sameTagSiblings.length > 1)
                    ordinal = sameTagSiblings.indexOf(element);
            }
            // Do not include text into this token, only tag / attributes.
            // Topmost node will get all the text.
            const conditionsString = conditions.length ? `[${conditions.join(' and ')}]` : '';
            const ordinalString = ordinal >= 0 ? `[${ordinal + 1}]` : '';
            tokens.unshift(`${tag}${ordinalString}${conditionsString}`);
        }
        return uniqueXPathSelector();
    },
    query(root, selector) {
        const document = root instanceof Document ? root : root.ownerDocument;
        if (!document)
            return;
        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
        for (let node = it.iterateNext(); node; node = it.iterateNext()) {
            if (node.nodeType === Node.ELEMENT_NODE)
                return node;
        }
    },
    queryAll(root, selector) {
        const result = [];
        const document = root instanceof Document ? root : root.ownerDocument;
        if (!document)
            return result;
        const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
        for (let node = it.iterateNext(); node; node = it.iterateNext()) {
            if (node.nodeType === Node.ELEMENT_NODE)
                result.push(node);
        }
        return result;
    }
};


/***/ })

/******/ });
//# sourceMappingURL=scriptSource.js.map